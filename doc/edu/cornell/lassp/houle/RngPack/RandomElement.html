<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><!--JBuilder QuickDoc-->
<HEAD>
<TITLE>Class edu.cornell.lassp.houle.RngPack.RandomElement</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
</HEAD>
<BODY>

<H2>
<FONT SIZE="-1">edu.cornell.lassp.houle.RngPack</FONT>
<BR>Class RandomElement</H2>
<DL>
<DT>public abstract class <B>RandomElement</B><DT>extends cern.colt.PersistentObject<DT>implements java.lang.Cloneable
</DL>
<DL><DD>RandomElement is an abstract class that encapsulates uniform random number generators. <p>Subclasses have entirelly deterministic behaviour: Constructing two instances with the same parameters at any two distinct points in time will produce identical sequences of numbers. <p> To base a class on it, you must define the method <CODE>raw()</CODE> as described below. It is also likely that you will want to define a constructor or another mechanism for seeding the the generator. The other classes defined in <CODE>RandomElement</CODE> add value to the numbers generated by <CODE>raw()</CODE> <P> <A HREF="../src/edu/cornell/lassp/houle/RngPack/RandomElement.java"> Source code </A> is available.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Version:</B><DD>1.0</DD>
<DT><B>Author:</B><DD><A HREF="http://www.msc.cornell.edu/~houle"> Paul Houle </A> (E-mail: <A HREF="mailto:houle@msc.cornell.edu">houle@msc.cornell.edu</A>)</DD>
<DT><B>See Also:</B><DD>RandomJava</DD>
<DD>RandomShuffle</DD>
</DL>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B>
</FONT></TD></TR></TABLE>

<A NAME="choose(int)"></A>

<H3>choose</H3>
<PRE>
public int <B>choose</B>(int&nbsp;hi)</PRE>
<DL><DD><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>hi</CODE> - upper limit of range</DD>
<DT><B>Returns:</B><DD>a random integer in the range 1,2,... ,<STRONG>hi</STRONG></DD>
</DL>
<HR>

<A NAME="choose(int, int)"></A>

<H3>choose</H3>
<PRE>
public int <B>choose</B>(int&nbsp;lo,
                  int&nbsp;hi)</PRE>
<DL><DD><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>lo</CODE> - lower limit of range</DD>
<DD><CODE>hi</CODE> - upper limit of range</DD>
<DT><B>Returns:</B><DD>a random integer in the range <STRONG>lo</STRONG>, <STRONG>lo</STRONG>+1, ... ,<STRONG>hi</STRONG></DD>
</DL>
<HR>

<A NAME="gaussian()"></A>

<H3>gaussian</H3>
<PRE>
public double <B>gaussian</B>()</PRE>
<DL><DD>gaussian() uses the Box-Muller algorithm to transform raw()'s into gaussian deviates.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a random real with a gaussian distribution, standard deviation</DD>
</DL>
<HR>

<A NAME="gaussian(double)"></A>

<H3>gaussian</H3>
<PRE>
public double <B>gaussian</B>(double&nbsp;sd)</PRE>
<DL><DD><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>sd</CODE> - standard deviation</DD>
<DT><B>Returns:</B><DD>a gaussian distributed random real with standard deviation <STRONG>sd</STRONG></DD>
</DL>
<HR>

<A NAME="powlaw(double, double)"></A>

<H3>powlaw</H3>
<PRE>
public double <B>powlaw</B>(double&nbsp;alpha,
                     double&nbsp;cut)</PRE>
<DL><DD>generate a power-law distribution with exponent <CODE>alpha</CODE> and lower cutoff <CODE>cut</CODE> <CENTER> </CENTER><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>alpha</CODE> - the exponent</DD>
<DD><CODE>cut</CODE> - the lower cutoff</DD>
</DL>
<HR>

<A NAME="raw()"></A>

<H3>raw</H3>
<PRE>
public abstract double <B>raw</B>()</PRE>
<DL><DD>Returns a uniformly distributed pseudo-random number. The abstract method that must be defined to make a working RandomElement. See the class <CODE>RandomJava</CODE> for an example of how to do this.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>a random double in the range (0,1).</DD>
<DT><B>See Also:</B><DD>RandomJava</DD>
</DL>
<HR>

<A NAME="raw(double[])"></A>

<H3>raw</H3>
<PRE>
public void <B>raw</B>(double[]&nbsp;d)</PRE>
<DL><DD>Fill an entire array with doubles. This method calls <CODE>raw(double d[],int n)</CODE> with <CODE>d=d.length</CODE>. Since this adds little overhead for <CODE>d.length</CODE> large, it is only necessary to override <CODE>raw(double d[],int n)</CODE><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>d</CODE> - array to be filled with doubles.</DD>
</DL>
<HR>

<A NAME="raw(double[], int)"></A>

<H3>raw</H3>
<PRE>
public void <B>raw</B>(double[]&nbsp;d,
                int&nbsp;n)</PRE>
<DL><DD>Fill part or all of an array with doubles. The method defined here uses multiple calls to <CODE>raw()</CODE> to fill the array. You can eliminate the overhead of multiple method calls by subclassing this with a version of the generator that fills the array. On our system this improves the efficiency of <CODE>Ranecu</CODE> by 20% when filling large arrays.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>d</CODE> - array to be filled with doubles</DD>
<DD><CODE>n</CODE> - number of doubles to generate</DD>
</DL>
<HR>

<A NAME="uniform(double, double)"></A>

<H3>uniform</H3>
<PRE>
public double <B>uniform</B>(double&nbsp;lo,
                      double&nbsp;hi)</PRE>
<DL><DD><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>lo</CODE> - lower limit of range</DD>
<DD><CODE>hi</CODE> - upper limit of range</DD>
<DT><B>Returns:</B><DD>a uniform random double in the range (<STRONG>lo</STRONG>,<STRONG>hi</STRONG>).</DD>
</DL>
<HR>

</BODY>
</HTML>